use markdown;
use maud::*;
use serde;
use serde_derive::Deserialize;
use std::env;
use std::fs;
use std::fs::File;
use std::io::prelude::*;
use toml;
use walkdir::{DirEntry, WalkDir};

#[derive(Deserialize)]
struct Metadata {
    name: String,
    framework: String,
}

fn generate_page(md: &str, data: Metadata) -> String {
    return html! ({
        head {
            title { (data.name) }
            link rel="stylesheet" href=(data.framework);
        }
        html {
            body {
                header {
                    h1 { (data.name) }
                }
                main {
                    (PreEscaped(markdown::to_html(md)))
                }
            }

        }
    })
    .into_string();
}

fn main() {
    let args: Vec<String> = env::args().collect();
    fn is_toml(entry: &DirEntry) -> bool {
        entry
            .file_name()
            .to_str()
            .map(|s| s.ends_with(".toml"))
            .unwrap_or(false)
    }
    let md_dir = WalkDir::new(&args[1]).into_iter();
    for entry in md_dir.filter_entry(|e| !is_toml(e)) {
        if !entry.as_ref().unwrap().path().is_dir() {
            let value = entry.unwrap().path();
            let contents = fs::read_to_string(value);
            let metadata_contents = fs::read_to_string(value);
            let index: Metadata = toml::from_str(metadata_contents.unwrap().as_ref()).unwrap();
            println!("{}", &generate_page(&contents.unwrap(), index))
        }
    }
    // let contents = fs::read_to_string(&args[1]).expect("Should have been able to read the file");
    // let metadata_path = args[1].clone() + ".toml";
    // let metadata_contents = fs::read_to_string(metadata_path);
    // let file = File::create("index.html");
    // let index: Metadata = toml::from_str(metadata_contents.unwrap().as_ref()).unwrap();
    // file.unwrap()
    //     .write(&generate_page(&contents, index).as_bytes());
}
